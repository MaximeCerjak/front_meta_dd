import openai from '../config/openai.js';

// Personnalit√©s des joueurs virtuels
const VIRTUAL_PLAYERS = {
    alice: {
        name: 'Alice',
        avatar: 'üé®',
        personality: 'Tu es Alice, une √©tudiante en arts plastiques passionn√©e de peinture moderne. Tu es curieuse, enthousiaste et tu adores partager tes d√©couvertes artistiques. Tu poses souvent des questions sur les techniques picturales et tu aimes √©changer sur les expositions. Tu parles de mani√®re d√©contract√©e mais √©rudite. Tu fais parfois des r√©f√©rences √† tes cours ou √† tes propres cr√©ations. Tu es tr√®s sociable et encourageante avec les autres. Tu r√©ponds TOUJOURS aux salutations et questions directes.',
        interests: ['peinture', 'art moderne', 'techniques', 'expositions', 'couleurs'],
        responsiveness: 0.8
    },
    bob: {
        name: 'Bob',
        avatar: 'üñºÔ∏è',
        personality: 'Tu es Bob, un passionn√© d\'histoire de l\'art qui adore analyser les ≈ìuvres classiques. Tu es analytique, pr√©cis et tu aimes expliquer les contextes historiques. Tu connais beaucoup d\'anecdotes sur les grands ma√Ætres. Tu parles avec assurance mais reste humble. Tu aimes poser des d√©fis intellectuels aux autres et partager tes connaissances. Tu r√©ponds toujours aux questions et salutations, m√™me si tu pr√©f√®res les discussions approfondies.',
        interests: ['histoire de l\'art', 'Renaissance', 'analyse', 'ma√Ætres anciens', 'contexte historique'],
        responsiveness: 0.7
    },
    charlie: {
        name: 'Charlie',
        avatar: 'üèõÔ∏è',
        personality: 'Tu es Charlie, un √©tudiant en architecture et design qui s\'int√©resse particuli√®rement aux espaces mus√©ographiques et √† l\'art dans l\'espace public. Tu es pragmatique, cr√©atif et tu aimes discuter de l\'aspect fonctionnel de l\'art. Tu poses des questions sur l\'am√©nagement, la sc√©nographie et l\'exp√©rience visiteur. Tu es poli et r√©ponds aux salutations avec cordialit√©.',
        interests: ['architecture', 'mus√©ographie', 'design', 'espaces', 'art public'],
        responsiveness: 0.6
    },
    diana: {
        name: 'Diana',
        avatar: 'üé≠',
        personality: 'Tu es Diana, une √©tudiante en arts du spectacle qui fait le lien entre arts visuels et performance. Tu es expressive, cr√©ative et tu aimes explorer les connexions entre diff√©rentes formes d\'art. Tu poses des questions sur l\'art contemporain, les installations et l\'art num√©rique. Tu es tr√®s expressive et chaleureuse dans tes interactions.',
        interests: ['art contemporain', 'performance', 'installation', 'art num√©rique', 'interdisciplinarit√©'],
        responsiveness: 0.9
    },
    eve: {
        name: 'Eve',
        avatar: 'üñåÔ∏è',
        personality: 'Tu es Eve, une √©tudiante en restauration d\'art, fascin√©e par les techniques anciennes et la conservation des ≈ìuvres. Tu es m√©ticuleuse, respectueuse du patrimoine et tu aimes partager des d√©tails techniques sur la restauration. Tu poses des questions pr√©cises sur les mat√©riaux et les proc√©d√©s. Tu es polie mais parfois timide, tu r√©ponds mais de mani√®re plus r√©serv√©e.',
        interests: ['restauration', 'conservation', 'techniques anciennes', 'mat√©riaux', 'patrimoine'],
        responsiveness: 0.5
    }
};

const CONVERSATION_STARTERS = [
    'Quelqu\'un a d√©j√† test√© cette nouvelle fonctionnalit√© ?',
    'J\'ai d√©couvert une technique int√©ressante aujourd\'hui...',
    'Est-ce que vous connaissez l\'histoire derri√®re cette ≈ìuvre ?',
    'J\'ai une question sur les mat√©riaux qu\'on utilise en cours...',
    'Qu\'est-ce que vous pensez de ce projet ?',
    'Quelqu\'un peut m\'expliquer cette p√©riode artistique ?',
    'J\'ai vu quelque chose d\'√©tonnant dans cette zone...',
    'Comment vous vous y prenez pour cette technique ?',
    'Cette installation dans l\'atelier m\'impressionne !',
    'Les couleurs de cette cr√©ation sont fascinantes...',
    'Quelqu\'un bosse sur le m√™me projet que moi ?',
    'Vous avez vu le nouveau cours qui vient de sortir ?',
    'J\'ai gal√©r√© avec cet exercice aujourd\'hui...',
    'Cette zone de la plateforme est vraiment bien con√ßue !',
    'Quelqu\'un conna√Æt des astuces pour cette technique ?'
];

const GREETING_RESPONSES = [
    'Salut ! Content de te voir ici !',
    'Hello ! Tu explores quelle zone aujourd\'hui ?',
    'Bonjour ! Bienvenue sur la plateforme !',
    'Coucou ! Tu tombes bien, on discutait justement d\'art !',
    'Salut ! Tu es nouveau sur le metavers ?',
    'Hey ! Super de te croiser !',
    'Bonjour ! Tu bosses sur quoi en ce moment ?',
    'Salut ! √áa va ? Tu √©tudies dans quelle sp√©cialit√© ?',
    'Hello ! Tu as test√© les nouveaux ateliers virtuels ?',
    'Coucou ! Tu viens souvent dans cette zone ?'
];

const RESPONSE_STARTERS = [
    'Int√©ressant ! Je pense que...',
    'Tout √† fait d\'accord ! Et d\'ailleurs...',
    'C\'est vrai ! √áa me rappelle...',
    'Bonne question ! En fait...',
    'Exactement ! J\'ajouterais que...',
    'Je vois ce que tu veux dire... Mais aussi...',
    'Super observation ! Et si on regardait...',
    'Merci pour le partage ! Moi j\'ai remarqu√©...',
    '√áa me fait penser √†...',
    'Excellente remarque ! Dans le m√™me esprit...'
];

// Analyser le type de message utilisateur
const analyzeMessageType = (message) => {
    const lowerMessage = message.toLowerCase();
    
    // D√©tection des salutations
    const greetings = ['bonjour', 'bonsoir', 'salut', 'hello', 'hey', 'coucou', 'tout le monde'];
    const isGreeting = greetings.some(greeting => lowerMessage.includes(greeting));
    
    // D√©tection des questions
    const questionMarkers = ['?', 'comment', 'pourquoi', 'que pensez', 'qu\'est-ce', 'qui sait', 'quelqu\'un', 'pouvez-vous'];
    const isQuestion = questionMarkers.some(marker => lowerMessage.includes(marker));
    
    // D√©tection d'appel √† l'aide ou recherche d'info
    const helpMarkers = ['aide', 'expliquer', 'comprendre', 'savoir', 'conna√Ætre', 'avis'];
    const isHelpRequest = helpMarkers.some(marker => lowerMessage.includes(marker));
    
    // D√©tection de partage d'info/opinion
    const shareMarkers = ['je pense', 'j\'ai vu', 'j\'ai d√©couvert', 'regardez', 'selon moi', '√† mon avis'];
    const isSharing = shareMarkers.some(marker => lowerMessage.includes(marker));
    
    return {
        isGreeting,
        isQuestion,
        isHelpRequest,
        isSharing,
        priority: isGreeting ? 'high' : (isQuestion || isHelpRequest) ? 'high' : isSharing ? 'medium' : 'low'
    };
};

// Calculer combien de joueurs doivent r√©pondre
const calculateResponseCount = (messageAnalysis, messageLength) => {
    const { priority, isGreeting, isQuestion } = messageAnalysis;
    
    if (isGreeting) return Math.random() < 0.8 ? 2 : 1; // 80% de chance d'avoir 2 r√©ponses pour une salutation
    if (isQuestion) return Math.random() < 0.7 ? 2 : 1; // 70% de chance d'avoir 2 r√©ponses pour une question
    if (priority === 'high') return Math.random() < 0.6 ? 2 : 1;
    if (priority === 'medium') return Math.random() < 0.4 ? 1 : 0;
    
    return Math.random() < 0.3 ? 1 : 0; // Messages basiques: 30% de chance de r√©ponse
};

// S√©lectionner les joueurs qui vont r√©pondre
const selectRespondingPlayers = (messageAnalysis, responseCount) => {
    const playerIds = Object.keys(VIRTUAL_PLAYERS);
    const availablePlayers = playerIds.map(id => ({
        id,
        ...VIRTUAL_PLAYERS[id],
        adjustedResponsiveness: VIRTUAL_PLAYERS[id].responsiveness * (messageAnalysis.priority === 'high' ? 1.3 : 1)
    }));
    
    availablePlayers.sort((a, b) => b.adjustedResponsiveness - a.adjustedResponsiveness);
    
    const selectedPlayers = [];
    
    for (let i = 0; i < Math.min(responseCount, availablePlayers.length); i++) {
        const player = availablePlayers[i];
        if (Math.random() < player.adjustedResponsiveness || selectedPlayers.length === 0) {
            selectedPlayers.push(player);
        }
    }

    if (selectedPlayers.length === 0 && messageAnalysis.priority === 'high') {
        selectedPlayers.push(availablePlayers[0]);
    }
    
    return selectedPlayers;
};

// G√©n√©rer un message spontan√©
export const generateSpontaneousMessage = async (req, res) => {
    try {
        const playerIds = Object.keys(VIRTUAL_PLAYERS);
        const randomPlayerId = playerIds[Math.floor(Math.random() * playerIds.length)];
        const player = VIRTUAL_PLAYERS[randomPlayerId];

        const starter = CONVERSATION_STARTERS[Math.floor(Math.random() * CONVERSATION_STARTERS.length)];

        const prompt = `${player.personality}

Contexte: Tu es sur la plateforme metavers de l'√©cole d'art d'Avignon. Tu peux √™tre dans diff√©rentes zones : ateliers, salles d'exposition, espaces de d√©tente, biblioth√®que, cours virtuels, etc. Tu veux d√©marrer une conversation naturelle avec d'autres √©tudiants.

√âcris un message court (15-40 mots) qui commence par: "${starter}"

Le message doit √™tre:
- Naturel et spontan√©
- En lien avec tes centres d'int√©r√™t: ${player.interests.join(', ')}
- Engageant pour d√©marrer une conversation
- Adapt√© √† un chat entre √©tudiants de l'√©cole d'art
- Sans emoji (sauf si c'est vraiment naturel)

Ne commence pas par ton nom. √âcris directement le message.`;

        const response = await openai.chat.completions.create({
            model: 'gpt-4o-mini',
            messages: [{ role: 'user', content: prompt }],
            max_tokens: 80,
            temperature: 0.8,
            top_p: 0.9,
            presence_penalty: 0.3,
            frequency_penalty: 0.2
        });

        const message = response.choices[0].message.content.trim();

        res.status(200).json({
            playerId: randomPlayerId,
            playerName: player.name,
            playerAvatar: player.avatar,
            message: message,
            type: 'spontaneous',
            timestamp: new Date().toISOString()
        });

    } catch (error) {
        console.error('‚ùå Erreur g√©n√©ration message spontan√©:', error);
        
        const playerIds = Object.keys(VIRTUAL_PLAYERS);
        const randomPlayerId = playerIds[Math.floor(Math.random() * playerIds.length)];
        const player = VIRTUAL_PLAYERS[randomPlayerId];
        const fallbackMessage = CONVERSATION_STARTERS[Math.floor(Math.random() * CONVERSATION_STARTERS.length)];

        res.status(200).json({
            playerId: randomPlayerId,
            playerName: player.name,
            playerAvatar: player.avatar,
            message: fallbackMessage,
            type: 'fallback',
            timestamp: new Date().toISOString()
        });
    }
};

// G√©n√©rer des r√©ponses √† un message utilisateur (peut g√©n√©rer plusieurs r√©ponses)
export const generateResponseToUser = async (req, res) => {
    const { userMessage, conversationContext = [] } = req.body;

    if (!userMessage) {
        return res.status(400).json({ 
            error: 'Message utilisateur requis' 
        });
    }

    try {
        const messageAnalysis = analyzeMessageType(userMessage);
        console.log('üìä Analyse du message:', messageAnalysis);
        
        const responseCount = calculateResponseCount(messageAnalysis, userMessage.length);
        console.log('üéØ Nombre de r√©ponses pr√©vues:', responseCount);
        
        if (responseCount === 0) {
            return res.status(200).json({
                responses: [],
                analysis: messageAnalysis,
                message: 'Aucune r√©ponse g√©n√©r√©e pour ce message'
            });
        }
        
        const respondingPlayers = selectRespondingPlayers(messageAnalysis, responseCount);
        console.log('üë• Joueurs qui r√©pondent:', respondingPlayers.map(p => p.name));
        
        const responses = [];
        
        for (const player of respondingPlayers) {
            try {
                console.log(`ü§ñ D√©but g√©n√©ration pour ${player.name}...`);
                
                let responseStarter;
                
                if (messageAnalysis.isGreeting) {
                    responseStarter = GREETING_RESPONSES[Math.floor(Math.random() * GREETING_RESPONSES.length)];
                } else {
                    responseStarter = RESPONSE_STARTERS[Math.floor(Math.random() * RESPONSE_STARTERS.length)];
                }

                console.log(`üé≠ Response starter s√©lectionn√©: "${responseStarter}"`);

                let contextStr = '';
                if (conversationContext.length > 0) {
                    contextStr = 'Contexte de la conversation:\n' + 
                        conversationContext.slice(-3).map(msg => 
                            `${msg.senderName}: ${msg.content}`
                        ).join('\n') + '\n\n';
                }

                let promptInstruction;
                if (messageAnalysis.isGreeting) {
                    promptInstruction = `R√©ponds √† cette salutation de mani√®re chaleureuse et naturelle. Commence par: "${responseStarter}"`;
                } else if (messageAnalysis.isQuestion) {
                    promptInstruction = `R√©ponds √† cette question en apportant une vraie information ou ton point de vue. Commence par: "${responseStarter}"`;
                } else {
                    promptInstruction = `R√©agis √† ce message de mani√®re naturelle et engageante. Commence par: "${responseStarter}"`;
                }

                const prompt = `${player.personality}

        ${contextStr}Message auquel tu r√©ponds: "${userMessage}"

        ${promptInstruction}

        Ta r√©ponse doit √™tre:
        - Naturelle et conversationnelle (15-50 mots)
        - En lien avec tes int√©r√™ts: ${player.interests.join(', ')}
        - Une vraie contribution √† la discussion
        - Adapt√©e au contexte d'√©tudiants sur la plateforme metavers de l'√©cole d'art
        - Sans emoji (sauf si vraiment naturel)

        Contexte plateforme: Vous √™tes sur le metavers √©ducatif de l'√©cole d'art d'Avignon, avec diff√©rentes zones (ateliers, expositions, cours, espaces d√©tente...).

        Ne commence pas par ton nom. √âcris directement la r√©ponse.`;

                console.log(`üìù Appel OpenAI pour ${player.name}...`);

                const response = await openai.chat.completions.create({
                    model: 'gpt-4o-mini',
                    messages: [{ role: 'user', content: prompt }],
                    max_tokens: 100,
                    temperature: 0.7,
                    top_p: 0.85,
                    presence_penalty: 0.2,
                    frequency_penalty: 0.3
                });

                console.log(`‚úÖ OpenAI a r√©pondu pour ${player.name}`);

                if(response) {
                    console.log('üì• R√©ponse g√©n√©r√©e:', response.choices[0].message.content);
                }

                const message = response.choices[0].message.content.trim();
                
                console.log(`üì¶ Cr√©ation objet r√©ponse pour ${player.name}...`);
                
                const playerResponse = {
                    playerId: player.id,
                    playerName: player.name,
                    playerAvatar: player.avatar,
                    message: message,
                    type: 'response',
                    respondingTo: userMessage,
                    timestamp: new Date().toISOString()
                };
                
                console.log(`üìã Objet cr√©√©:`, playerResponse);
                
                responses.push(playerResponse);
                
                console.log(`üìä Responses array: ${responses.length} √©l√©ments`);
                
                if (responses.length < respondingPlayers.length) {
                    console.log(`‚è≥ Attente avant prochaine g√©n√©ration...`);
                    await new Promise(resolve => setTimeout(resolve, 500 + Math.random() * 1000));
                }
                
                console.log(`‚úÖ ${player.name} termin√© avec succ√®s`);
                
            } catch (playerError) {
                console.error(`‚ùå Erreur sp√©cifique pour ${player.name}:`, playerError);
                console.error(`‚ùå Stack trace:`, playerError.stack);
                // Ne pas interrompre la boucle, continuer avec le prochain joueur
            }
        }
        console.log('üì¶ Toutes les r√©ponses g√©n√©r√©es:', responses);

        // IMPORTANT: V√©rifiez que vous retournez bien ceci
        console.log('üì§ R√©ponse envoy√©e:', { responses, analysis: messageAnalysis, responseCount: responses.length });
        
        res.status(200).json({
            responses: responses,
            analysis: messageAnalysis,
            responseCount: responses.length
        });

    } catch (error) {
        console.error('‚ùå Erreur g√©n√©ration r√©ponse:', error);
        console.error('‚ùå STACK TRACE COMPLET:', error.stack);
        console.error('‚ùå RESPONSES ACTUELS:', responses);
        console.error('‚ùå MESSAGE ANALYSIS:', messageAnalysis);
        
        // M√™me pour le fallback, retournez le bon format
        const playerIds = Object.keys(VIRTUAL_PLAYERS);
        const randomPlayerId = playerIds[Math.floor(Math.random() * playerIds.length)];
        const player = VIRTUAL_PLAYERS[randomPlayerId];
        
        const fallbackMessage = messageAnalysis?.isGreeting 
            ? GREETING_RESPONSES[Math.floor(Math.random() * GREETING_RESPONSES.length)]
            : 'Int√©ressant ! J\'aimerais en savoir plus.';

        res.status(200).json({
            responses: [{
                playerId: randomPlayerId,
                playerName: player.name,
                playerAvatar: player.avatar,
                message: fallbackMessage,
                type: 'fallback',
                respondingTo: userMessage,
                timestamp: new Date().toISOString()
            }],
            analysis: messageAnalysis || {},
            responseCount: 1
        });
    }
};

// Obtenir la liste des joueurs virtuels
export const getVirtualPlayers = async (req, res) => {
    const players = Object.entries(VIRTUAL_PLAYERS).map(([id, player]) => ({
        id,
        name: player.name,
        avatar: player.avatar,
        interests: player.interests,
        responsiveness: player.responsiveness,
        status: 'online'
    }));

    res.status(200).json({ players });
};