# .gitlab-ci.yml (version mise √† jour)

# Variables globales
variables:
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: "/certs"
  IMAGE_NAME: $CI_REGISTRY_IMAGE/chatbot-service
  IMAGE_TAG: $CI_COMMIT_SHORT_SHA
  SERVICE_NAME: "chatbot-service"
  SERVICE_PORT: "6000"
  NODE_VERSION: "18"

# Services n√©cessaires
services:
  - docker:dind

# Stages de la pipeline
stages:
  - install
  - lint
  - test
  - security
  - build
  - deploy

# Cache pour acc√©l√©rer les builds
cache:
  key: ${CI_COMMIT_REF_SLUG}
  paths:
    - node_modules/
    - .npm/

# Template pour les jobs Node.js
.node_template: &node_template
  image: node:${NODE_VERSION}-alpine
  before_script:
    - npm ci --cache .npm --prefer-offline
  cache:
    key: ${CI_COMMIT_REF_SLUG}
    paths:
      - node_modules/
      - .npm/

# Job d'installation des d√©pendances
install_dependencies:
  <<: *node_template
  stage: install
  script:
    - echo "üì¶ Installation des d√©pendances..."
    - npm ci --cache .npm --prefer-offline
    - echo "‚úÖ D√©pendances install√©es avec succ√®s"
  artifacts:
    paths:
      - node_modules/
    expire_in: 1 hour
  only:
    - merge_requests
    - develop
    - main

# Job de lint
lint:
  <<: *node_template
  stage: lint
  dependencies:
    - install_dependencies
  script:
    - echo "üîç Analyse de la qualit√© du code..."
    - npm run lint
    - echo "‚úÖ Code conforme aux standards"
  allow_failure: false
  only:
    - merge_requests
    - develop
    - main

# Job de tests unitaires
test_unit:
  <<: *node_template
  stage: test
  dependencies:
    - install_dependencies
  script:
    - echo "üß™ Ex√©cution des tests unitaires..."
    - npm run test:ci
    - echo "‚úÖ Tests unitaires r√©ussis"
  coverage: '/Lines\s*:\s*(\d+\.\d*)%/'
  artifacts:
    when: always
    reports:
      junit: coverage/junit.xml
      coverage_report:
        coverage_format: cobertura
        path: coverage/cobertura-coverage.xml
    paths:
      - coverage/
    expire_in: 1 week
  only:
    - merge_requests
    - develop
    - main

# Job de tests d'int√©gration
test_integration:
  <<: *node_template
  stage: test
  dependencies:
    - install_dependencies
  script:
    - echo "üîó Ex√©cution des tests d'int√©gration..."
    - npm run test -- --testPathPattern="integration" --verbose
    - echo "‚úÖ Tests d'int√©gration r√©ussis"
  allow_failure: true
  only:
    - merge_requests
    - develop
    - main

# Job de s√©curit√© - Audit des d√©pendances
security_audit:
  <<: *node_template
  stage: security
  dependencies:
    - install_dependencies
  script:
    - echo "üîí Audit de s√©curit√© des d√©pendances..."
    - npm audit --audit-level=moderate
    - echo "‚úÖ Audit de s√©curit√© termin√©"
  allow_failure: true
  artifacts:
    when: always
    reports:
      dependency_scanning: gl-dependency-scanning-report.json
    expire_in: 1 week
  only:
    - merge_requests
    - develop
    - main

# Job de s√©curit√© - Scan des secrets
security_secrets:
  image: alpine:latest
  stage: security
  before_script:
    - apk add --no-cache git grep
  script:
    - echo "üîç Recherche de secrets dans le code..."
    - |
      # Recherche de patterns de secrets communs
      echo "V√©rification des cl√©s API..."
      if grep -r -i "api.key\|secret\|password\|token" --include="*.js" --include="*.json" src/ || true; then
        echo "‚ö†Ô∏è Attention: V√©rifiez que les secrets ne sont pas expos√©s"
      fi
      echo "‚úÖ Scan des secrets termin√©"
  allow_failure: true
  only:
    - merge_requests
    - develop
    - main

# Job de build avec tests de fum√©e
build_and_smoke_test:
  image: docker:latest
  stage: build
  dependencies:
    - test_unit
  before_script:
    - echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
  script:
    - |
      if [ "$CI_COMMIT_REF_NAME" = "main" ]; then
        echo "üöÄ Construction PRODUCTION..."
        docker build -f ./config/docker/Dockerfile.prod -t $IMAGE_NAME:$IMAGE_TAG .
        docker tag $IMAGE_NAME:$IMAGE_TAG $IMAGE_NAME:latest
        
        # Test de fum√©e - v√©rifier que l'image d√©marre
        echo "üí® Test de fum√©e..."
        docker run -d --name smoke-test -p 6000:6000 -e OPENAI_API_KEY=test $IMAGE_NAME:$IMAGE_TAG
        sleep 10
        # V√©rifier que le conteneur tourne
        if docker ps | grep smoke-test; then
          echo "‚úÖ Test de fum√©e r√©ussi"
          docker stop smoke-test
          docker rm smoke-test
        else
          echo "‚ùå Test de fum√©e √©chou√©"
          docker logs smoke-test
          exit 1
        fi
        
        docker push $IMAGE_NAME:$IMAGE_TAG
        docker push $IMAGE_NAME:latest
        echo "‚úÖ Image PROD pouss√©e: $IMAGE_NAME:$IMAGE_TAG"
      else
        echo "üîß Construction D√âVELOPPEMENT..."
        docker build -f ./config/docker/Dockerfile.dev -t $IMAGE_NAME:$IMAGE_TAG-dev .
        docker tag $IMAGE_NAME:$IMAGE_TAG-dev $IMAGE_NAME:dev-latest
        docker push $IMAGE_NAME:$IMAGE_TAG-dev
        docker push $IMAGE_NAME:dev-latest
        echo "‚úÖ Image DEV pouss√©e: $IMAGE_NAME:$IMAGE_TAG-dev"
      fi
  after_script:
    - docker system prune -f
  only:
    - develop
    - main

# Job de d√©ploiement automatique (optionnel)
deploy_dev:
  image: alpine:latest
  stage: deploy
  dependencies:
    - build_and_smoke_test
  before_script:
    - apk add --no-cache curl
  script:
    - echo "üöÄ D√©ploiement en environnement de d√©veloppement..."
    - echo "Image √† d√©ployer: $IMAGE_NAME:$IMAGE_TAG-dev"
    # Ici vous pourriez ajouter vos commandes de d√©ploiement
    # Par exemple: kubectl, docker-compose, webhook, etc.
    - echo "‚úÖ D√©ploiement DEV termin√©"
  environment:
    name: development
    url: https://dev-chatbot.example.com
  when: manual
  only:
    - develop

deploy_prod:
  image: alpine:latest
  stage: deploy
  dependencies:
    - build_and_smoke_test
  before_script:
    - apk add --no-cache curl
  script:
    - echo "üöÄ D√©ploiement en PRODUCTION..."
    - echo "Image √† d√©ployer: $IMAGE_NAME:$IMAGE_TAG"
    # Commandes de d√©ploiement production
    - echo "‚úÖ D√©ploiement PROD termin√©"
  environment:
    name: production
    url: https://chatbot.example.com
  when: manual
  only:
    - main

# Job de nettoyage des artefacts
cleanup:
  image: alpine:latest
  stage: deploy
  script:
    - echo "üßπ Nettoyage des artefacts anciens..."
    - echo "‚úÖ Nettoyage termin√©"
  when: always
  allow_failure: true
  only:
    - develop
    - main