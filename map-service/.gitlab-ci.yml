# =========================
# Variables globales
# =========================
variables:
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: "/certs"
  IMAGE_NAME: $CI_REGISTRY_IMAGE/map-service
  IMAGE_TAG: $CI_COMMIT_SHORT_SHA
  SERVICE_NAME: "map-service"
  SERVICE_PORT: "5000"
  NODE_VERSION: "18"
  # Tests
  NODE_ENV: test

# =========================
# Services nÃ©cessaires
# =========================
services:
  - docker:dind

# =========================
# Stages
# =========================
stages:
  - install
  - quality
  - test
  - build
  - deploy

# =========================
# Cache npm
# =========================
cache:
  key: ${CI_COMMIT_REF_SLUG}
  paths:
    - node_modules/
    - .npm/

# =========================
# Template Node
# =========================
.node_template: &node_template
  image: node:${NODE_VERSION}-alpine
  before_script:
    - echo "ðŸ“¦ PrÃ©paration npm cacheâ€¦"
    - npm ci --cache .npm --prefer-offline

# ===================================
# JOBS EXÃ‰CUTÃ‰S SUR TOUTES LES BRANCHES
# ===================================

# Installation des dÃ©pendances
install_dependencies:
  <<: *node_template
  stage: install
  script:
    - echo "ðŸ“¦ Installation des dÃ©pendancesâ€¦"
    - npm ci --cache .npm --prefer-offline
    - echo "âœ… DÃ©pendances installÃ©es"
  artifacts:
    paths:
      - node_modules/
    expire_in: 1 hour
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == "develop"
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_COMMIT_BRANCH =~ /^feat(ure)?\/.*/
    - if: $CI_COMMIT_BRANCH =~ /^fix\/.*/
    - if: $CI_COMMIT_BRANCH =~ /^hotfix\/.*/
    - if: $CI_COMMIT_BRANCH =~ /^bugfix\/.*/
    - if: $CI_COMMIT_BRANCH =~ /^chore\/.*/
    - if: $CI_COMMIT_BRANCH =~ /^refactor\/.*/

# Lint
lint:
  <<: *node_template
  stage: quality
  dependencies:
    - install_dependencies
  script:
    - echo "ðŸ” Lintingâ€¦"
    - npm run lint
    - echo "âœ… Code conforme"
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == "develop"
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_COMMIT_BRANCH =~ /^feat(ure)?\/.*/
    - if: $CI_COMMIT_BRANCH =~ /^fix\/.*/
    - if: $CI_COMMIT_BRANCH =~ /^hotfix\/.*/
    - if: $CI_COMMIT_BRANCH =~ /^bugfix\/.*/
    - if: $CI_COMMIT_BRANCH =~ /^chore\/.*/
    - if: $CI_COMMIT_BRANCH =~ /^refactor\/.*/

# Audit de sÃ©curitÃ©
security_audit:
  <<: *node_template
  stage: quality
  dependencies:
    - install_dependencies
  script:
    - echo "ðŸ”’ Audit de sÃ©curitÃ© npmâ€¦"
    - npm audit --audit-level=moderate || true
    - echo "âœ… Audit terminÃ© (non bloquant)"
  allow_failure: true
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == "develop"
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_COMMIT_BRANCH =~ /^feat(ure)?\/.*/
    - if: $CI_COMMIT_BRANCH =~ /^fix\/.*/
    - if: $CI_COMMIT_BRANCH =~ /^hotfix\/.*/
    - if: $CI_COMMIT_BRANCH =~ /^bugfix\/.*/
    - if: $CI_COMMIT_BRANCH =~ /^chore\/.*/
    - if: $CI_COMMIT_BRANCH =~ /^refactor\/.*/

# Tests unitaires et d'intÃ©gration
test_unit:
  <<: *node_template
  stage: test
  dependencies:
    - install_dependencies
  script:
    - echo "ðŸ§ª Tests unitaires et d'intÃ©grationâ€¦"
    - npm run test:ci
    - echo "âœ… Tests OK"
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage/cobertura-coverage.xml
      junit: coverage/junit.xml
    paths:
      - coverage/
    expire_in: 1 week
  coverage: '/Lines\s*:\s*(\d+\.\d*)%/'
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == "develop"
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_COMMIT_BRANCH =~ /^feat(ure)?\/.*/
    - if: $CI_COMMIT_BRANCH =~ /^fix\/.*/
    - if: $CI_COMMIT_BRANCH =~ /^hotfix\/.*/
    - if: $CI_COMMIT_BRANCH =~ /^bugfix\/.*/
    - if: $CI_COMMIT_BRANCH =~ /^chore\/.*/
    - if: $CI_COMMIT_BRANCH =~ /^refactor\/.*/

# Tests avec base de donnÃ©es rÃ©elle (optionnel)
test_database:
  image: node:${NODE_VERSION}-alpine
  stage: test
  services:
    - postgres:13-alpine
  variables:
    POSTGRES_DB: map_service_test
    POSTGRES_USER: test_user
    POSTGRES_PASSWORD: test_password
    DB_HOST: postgres
    DB_NAME: map_service_test
    DB_USER: test_user
    DB_PASSWORD: test_password
  dependencies:
    - install_dependencies
  before_script:
    - npm ci --cache .npm --prefer-offline
    - apk add --no-cache postgresql-client
    - |
      until pg_isready -h postgres -p 5432; do
        echo "Attente de PostgreSQL..."
        sleep 2
      done
  script:
    - echo "ðŸ—„ï¸ Tests avec base de donnÃ©es rÃ©elleâ€¦"
    - npm run test -- --testPathPattern=database --verbose || echo "Tests DB ignorÃ©s si pas configurÃ©s"
    - echo "âœ… Tests DB terminÃ©s"
  allow_failure: true
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == "develop"
    - if: $CI_COMMIT_BRANCH == "main"

# Scan de secrets simple (non bloquant)
security_secrets:
  image: alpine:latest
  stage: quality
  before_script:
    - apk add --no-cache git grep
  script:
    - echo "ðŸ” Scan de secretsâ€¦"
    - |
      if grep -RniE "api[_-]?key|secret|password|token" --include="*.js" --include="*.json" src/ || true; then
        echo "âš ï¸ VÃ©rifiez que des secrets ne sont pas exposÃ©s."
      fi
    - echo "âœ… Scan terminÃ©"
  allow_failure: true
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == "develop"
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_COMMIT_BRANCH =~ /^feat(ure)?\/.*/
    - if: $CI_COMMIT_BRANCH =~ /^fix\/.*/
    - if: $CI_COMMIT_BRANCH =~ /^hotfix\/.*/
    - if: $CI_COMMIT_BRANCH =~ /^bugfix\/.*/
    - if: $CI_COMMIT_BRANCH =~ /^chore\/.*/
    - if: $CI_COMMIT_BRANCH =~ /^refactor\/.*/

# ===================================
# BUILD (sÃ©parÃ© dev / prod)
# ===================================

# Build DEV (branche develop)
build_dev:
  image: docker:latest
  stage: build
  before_script:
    - echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
  script:
    - echo "ðŸ”§ Build DEVâ€¦"
    - docker build -f ./config/docker/Dockerfile.dev -t $IMAGE_NAME:$IMAGE_TAG-dev .
    - docker tag $IMAGE_NAME:$IMAGE_TAG-dev $IMAGE_NAME:dev-latest
    - docker push $IMAGE_NAME:$IMAGE_TAG-dev
    - docker push $IMAGE_NAME:dev-latest
    - echo "âœ… Image DEV poussÃ©e => $IMAGE_NAME:$IMAGE_TAG-dev"
  dependencies:
    - test_unit
  rules:
    - if: $CI_COMMIT_BRANCH == "develop"

# Build PROD (branche main) + smoke test
build_prod:
  image: docker:latest
  stage: build
  before_script:
    - echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
  script:
    - echo "ðŸš€ Build PRODâ€¦"
    - docker build -f ./config/docker/Dockerfile.prod -t $IMAGE_NAME:$IMAGE_TAG .
    - docker tag $IMAGE_NAME:$IMAGE_TAG $IMAGE_NAME:latest
    # Test de fumÃ©e : dÃ©marrage container
    - echo "ðŸ’¨ Smoke testâ€¦"
    - docker run -d --name smoke-test -p ${SERVICE_PORT}:${SERVICE_PORT} -e NODE_ENV=production $IMAGE_NAME:$IMAGE_TAG
    - sleep 10
    - |
      if docker ps | grep -q smoke-test; then
        echo "âœ… Smoke test OK"
        docker stop smoke-test && docker rm smoke-test
      else
        echo "âŒ Smoke test KO"
        docker logs smoke-test || true
        exit 1
      fi
    - docker push $IMAGE_NAME:$IMAGE_TAG
    - docker push $IMAGE_NAME:latest
    - echo "âœ… Image PROD poussÃ©e => $IMAGE_NAME:$IMAGE_TAG"
  after_script:
    - docker system prune -f || true
  dependencies:
    - test_unit
  rules:
    - if: $CI_COMMIT_BRANCH == "main"

# ===================================
# DÃ‰PLOIEMENT
# ===================================

deploy_staging:
  image: alpine/helm:latest
  stage: deploy
  script:
    - echo "ðŸš¢ DÃ©ploiement STAGINGâ€¦"
    - echo "Image => $IMAGE_NAME:$IMAGE_TAG-dev"
    - echo "Configuration environnement stagingâ€¦"
    # Ici, ajoutez vos commandes Helm/Kubernetes pour le dÃ©ploiement
    # helm upgrade --install map-service-staging ./helm-chart --set image.tag=$IMAGE_TAG-dev
  environment:
    name: staging
    url: https://staging-map-service.example.com
  dependencies:
    - build_dev
  rules:
    - if: $CI_COMMIT_BRANCH == "develop"
      when: manual

deploy_production:
  image: alpine/helm:latest
  stage: deploy
  script:
    - echo "ðŸš€ DÃ©ploiement PRODUCTIONâ€¦"
    - echo "Image => $IMAGE_NAME:$IMAGE_TAG"
    - echo "Configuration environnement productionâ€¦"
    # Ici, ajoutez vos commandes Helm/Kubernetes pour le dÃ©ploiement
    # helm upgrade --install map-service ./helm-chart --set image.tag=$IMAGE_TAG
  environment:
    name: production
    url: https://map-service.example.com
  dependencies:
    - build_prod
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: manual

# ===================================
# JOBS UTILITAIRES
# ===================================

# Nettoyage (programmable)
cleanup:
  image: docker:latest
  stage: deploy
  script:
    - echo "ðŸ§¹ Nettoyage d'images anciennesâ€¦"
    - docker image prune -a --filter "until=720h" --force || true
    - echo "âœ… Nettoyage terminÃ©"
  rules:
    - if: $CI_PIPELINE_SOURCE == "schedule"
      when: manual

# Validation MR (agrÃ©gateur)
validate_mr:
  <<: *node_template
  stage: test
  dependencies:
    - install_dependencies
    - lint
    - test_unit
    - security_audit
  script:
    - echo "âœ… Validation MR"
    - echo "- Lint âœ…"
    - echo "- Unit tests âœ…"
    - echo "- Security audit âœ…"
    - echo "ðŸŽ‰ PrÃªt Ã  merger !"
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"