# Variables globales
variables:
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: "/certs"
  IMAGE_NAME: $CI_REGISTRY_IMAGE/asset-service
  IMAGE_TAG: $CI_COMMIT_SHORT_SHA
  SERVICE_NAME: "asset-service"
  SERVICE_PORT: "4000"
  # Variables pour les tests
  NODE_ENV: test
  DB_NAME: asset_service_test
  DB_USER: test_user
  DB_PASSWORD: test_password
  DB_HOST: localhost

# Services n√©cessaires
services:
  - docker:dind
  - postgres:14

# Stages de la pipeline
stages:
  - install
  - lint
  - test
  - security
  - build
  - deploy

# Cache pour acc√©l√©rer les builds
cache:
  key: ${CI_COMMIT_REF_SLUG}
  paths:
    - node_modules/
    - .npm/

# Job d'installation des d√©pendances
install_dependencies:
  image: node:18-alpine
  stage: install
  script:
    - npm ci --cache .npm --prefer-offline
  artifacts:
    paths:
      - node_modules/
    expire_in: 1 hour
  only:
    - merge_requests
    - develop
    - main

# Job de lint
lint:
  image: node:18-alpine
  stage: lint
  dependencies:
    - install_dependencies
  script:
    - echo "üîç Lancement du linting..."
    - npm run lint
    - echo "‚úÖ Linting termin√© avec succ√®s"
  only:
    - merge_requests
    - develop
    - main

# Job de test unitaire
test_unit:
  image: node:18-alpine
  stage: test
  dependencies:
    - install_dependencies
  variables:
    POSTGRES_DB: $DB_NAME
    POSTGRES_USER: $DB_USER
    POSTGRES_PASSWORD: $DB_PASSWORD
    POSTGRES_HOST_AUTH_METHOD: trust
  script:
    - echo "üß™ Lancement des tests unitaires..."
    - npm run test:ci
    - echo "‚úÖ Tests unitaires termin√©s"
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage/cobertura-coverage.xml
      junit: coverage/junit.xml
    paths:
      - coverage/
    expire_in: 1 week
  coverage: '/Lines\s*:\s*(\d+\.\d*)%/'
  only:
    - merge_requests
    - develop
    - main

# Job de test d'int√©gration
test_integration:
  image: node:18-alpine
  stage: test
  dependencies:
    - install_dependencies
  services:
    - postgres:14
  variables:
    POSTGRES_DB: $DB_NAME
    POSTGRES_USER: $DB_USER
    POSTGRES_PASSWORD: $DB_PASSWORD
    POSTGRES_HOST_AUTH_METHOD: trust
  before_script:
    - apk add --no-cache postgresql-client
    - until pg_isready -h postgres -U $DB_USER; do sleep 1; done
    - createdb -h postgres -U $DB_USER $DB_NAME || true
  script:
    - echo "üîó Lancement des tests d'int√©gration..."
    - npm run test -- --testPathPattern=integration
    - echo "‚úÖ Tests d'int√©gration termin√©s"
  only:
    - merge_requests
    - develop
    - main

# Job de s√©curit√©
security_audit:
  image: node:18-alpine
  stage: security
  dependencies:
    - install_dependencies
  script:
    - echo "üîí Audit de s√©curit√© des d√©pendances..."
    - npm audit --audit-level=moderate
    - echo "‚úÖ Audit de s√©curit√© termin√©"
  allow_failure: true
  only:
    - merge_requests
    - develop
    - main

# Job de build avec Dockerfile conditionnel
build:
  image: docker:latest
  stage: build
  before_script:
    - echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
  script:
    - |
      if [ "$CI_COMMIT_REF_NAME" = "main" ]; then
        echo "üöÄ Construction PRODUCTION..."
        docker build -f ./config/docker/Dockerfile.prod -t $IMAGE_NAME:$IMAGE_TAG .
        docker tag $IMAGE_NAME:$IMAGE_TAG $IMAGE_NAME:latest
        docker push $IMAGE_NAME:$IMAGE_TAG
        docker push $IMAGE_NAME:latest
        echo "‚úÖ Image PROD pouss√©e: $IMAGE_NAME:$IMAGE_TAG"
      else
        echo "üîß Construction D√âVELOPPEMENT..."
        docker build -f ./config/docker/Dockerfile.dev -t $IMAGE_NAME:$IMAGE_TAG-dev .
        docker tag $IMAGE_NAME:$IMAGE_TAG-dev $IMAGE_NAME:dev-latest
        docker push $IMAGE_NAME:$IMAGE_TAG-dev
        docker push $IMAGE_NAME:dev-latest
        echo "‚úÖ Image DEV pouss√©e: $IMAGE_NAME:$IMAGE_TAG-dev"
      fi
  dependencies:
    - test_unit
    - test_integration
  only:
    - develop
    - main

# Job de d√©ploiement automatique (optionnel)
deploy_staging:
  image: alpine/helm:latest
  stage: deploy
  script:
    - echo "üö¢ D√©ploiement en staging..."
    - echo "Service deploy√© avec l'image: $IMAGE_NAME:$IMAGE_TAG-dev"
    # Ici vous pouvez ajouter vos commandes de d√©ploiement Kubernetes/Docker Swarm
  environment:
    name: staging
    url: https://staging.example.com
  only:
    - develop
  when: manual

deploy_production:
  image: alpine/helm:latest
  stage: deploy
  script:
    - echo "üöÄ D√©ploiement en production..."
    - echo "Service deploy√© avec l'image: $IMAGE_NAME:$IMAGE_TAG"
    # Ici vous pouvez ajouter vos commandes de d√©ploiement Kubernetes/Docker Swarm
  environment:
    name: production
    url: https://production.example.com
  only:
    - main
  when: manual

# Job de nettoyage des images Docker anciennes
cleanup:
  image: docker:latest
  stage: deploy
  script:
    - echo "üßπ Nettoyage des anciennes images..."
    # Supprimer les images de plus de 30 jours
    - docker image prune -a --filter "until=720h" --force || true
  only:
    - schedules
  when: manual