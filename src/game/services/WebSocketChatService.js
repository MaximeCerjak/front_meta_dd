// src/game/services/WebSocketChatService.js - VERSION AVEC IA
import { EventBus } from '../EventBus';
import ApiManager from '../../api/ApiManager';

/**
 * Service de simulation WebSocket pour le chat entre joueurs
 * Utilise l'IA pour g√©n√©rer des conversations naturelles
 */
export default class WebSocketChatService {
    constructor() {
        this.isConnected = false;
        this.currentUser = null;
        this.connectedPlayers = [];
        this.messageHistory = [];
        this.simulationInterval = null;
        this.responseTimeout = null;
        
        // Joueurs fictifs (seront remplac√©s par les donn√©es du backend)
        this.virtualPlayers = [];
    }

    /**
     * Initialise le service et simule la connexion
     */
    async connect() {
        return new Promise(async (resolve) => {
            console.log('WebSocketChatService - Connexion en cours...');
            
            try {
                // R√©cup√©rer les joueurs virtuels depuis le backend
                const playersData = await ApiManager.getVirtualPlayers();
                this.virtualPlayers = playersData.players;
                console.log('Joueurs virtuels charg√©s:', this.virtualPlayers);
            } catch (error) {
                console.warn('Impossible de charger les joueurs virtuels, utilisation des donn√©es par d√©faut');
                // Fallback avec joueurs par d√©faut
                this.virtualPlayers = [
                    { id: 'alice', name: 'Alice', avatar: 'üé®', status: 'online', scene: 'Museumreception' },
                    { id: 'bob', name: 'Bob', avatar: 'üñºÔ∏è', status: 'online', scene: 'Exhibitionroom' },
                    { id: 'charlie', name: 'Charlie', avatar: 'üèõÔ∏è', status: 'online', scene: 'Welcomeisle' },
                    { id: 'diana', name: 'Diana', avatar: 'üé≠', status: 'online', scene: 'Intro' },
                    { id: 'eve', name: 'Eve', avatar: 'üñåÔ∏è', status: 'online', scene: 'Sandbox' }
                ];
            }
            
            // Simuler un d√©lai de connexion
            setTimeout(() => {
                this.isConnected = true;
                this.connectedPlayers = [...this.virtualPlayers];
                
                // Ajouter l'utilisateur actuel √† la liste
                this.currentUser = {
                    id: 'user_' + Date.now(),
                    username: localStorage.getItem('username') || 'Joueur',
                    avatar: 'üßù',
                    status: 'online',
                    scene: 'Intro'
                };
                this.connectedPlayers.push(this.currentUser);
                
                console.log('WebSocketChatService - Connect√© avec succ√®s');
                console.log('Joueurs connect√©s:', this.connectedPlayers);
                
                // D√©marrer la simulation de messages automatiques avec IA
                this.startAIMessageSimulation();
                
                // √âmettre l'√©v√©nement de connexion
                EventBus.emit('websocket-connected', {
                    connectedPlayers: this.connectedPlayers,
                    currentUser: this.currentUser
                });
                
                resolve(true);
            }, 1000);
        });
    }

    /**
     * Simule la d√©connexion WebSocket
     */
    disconnect() {
        this.isConnected = false;
        this.stopAIMessageSimulation();
        this.connectedPlayers = [];
        
        EventBus.emit('websocket-disconnected');
        console.log('WebSocketChatService - D√©connect√©');
    }

    /**
     * Envoie un message (simulation)
     */
    sendMessage(content, type = 'global') {
        if (!this.isConnected) {
            console.warn('Pas connect√© au WebSocket');
            return false;
        }

        const message = {
            id: 'msg_' + Date.now(),
            senderId: this.currentUser.id,
            senderName: this.currentUser.username,
            senderAvatar: this.currentUser.avatar,
            content: content.trim(),
            type, // 'global', 'scene', 'private'
            scene: this.currentUser.scene,
            timestamp: new Date().toISOString(),
            isOwn: true
        };

        // Ajouter √† l'historique
        this.messageHistory.push(message);

        // √âmettre le message imm√©diatement
        EventBus.emit('websocket-message-received', message);

        console.log('Message envoy√©:', message);

        // Simuler une r√©ponse avec IA apr√®s un d√©lai
        this.simulateAIResponse(message);

        return true;
    }

    /**
     * D√©marre la simulation de messages automatiques avec IA
     */
    startAIMessageSimulation() {
        console.log('WebSocketChatService - D√©marrage simulation IA');
        
        // Premier message apr√®s 3 secondes
        setTimeout(() => {
            if (this.isConnected) {
                this.generateSpontaneousMessage();
            }
        }, 3000);

        // Messages spontan√©s p√©riodiques (toutes les 20-40 secondes)
        this.simulationInterval = setInterval(() => {
            if (this.isConnected && Math.random() > 0.4) { // 60% de chance
                this.generateSpontaneousMessage();
            }
        }, 20000 + Math.random() * 20000); // 20-40 secondes
    }

    /**
     * Arr√™te la simulation de messages automatiques
     */
    stopAIMessageSimulation() {
        if (this.simulationInterval) {
            clearInterval(this.simulationInterval);
            this.simulationInterval = null;
        }
        if (this.responseTimeout) {
            clearTimeout(this.responseTimeout);
            this.responseTimeout = null;
        }
    }

    /**
     * G√©n√®re un message spontan√© via l'IA
     */
    async generateSpontaneousMessage() {
        try {
            console.log('G√©n√©ration message spontan√©...');
            const response = await ApiManager.generateSpontaneousMessage();
            
            const message = {
                id: 'ai_spont_' + Date.now(),
                senderId: response.playerId,
                senderName: response.playerName,
                senderAvatar: response.playerAvatar,
                content: response.message,
                type: 'global',
                scene: this.getRandomScene(),
                timestamp: response.timestamp,
                isOwn: false
            };

            this.messageHistory.push(message);
            EventBus.emit('websocket-message-received', message);
            
            console.log('Message spontan√© IA re√ßu:', message);
            
        } catch (error) {
            console.error('Erreur g√©n√©ration message spontan√©:', error);
            // Fallback avec message simple
            this.simulateSimpleMessage();
        }
    }

    /**
     * Simule une r√©ponse avec IA √† un message utilisateur
     */
    async simulateAIResponse(originalMessage) {
        // 70% de chance d'avoir une r√©ponse
        if (Math.random() > 0.3) {
            // D√©lai r√©aliste de r√©ponse (1-4 secondes)
            const delay = Math.random() * 3000 + 1000;
            
            this.responseTimeout = setTimeout(async () => {
                try {
                    console.log('G√©n√©ration r√©ponse IA √†:', originalMessage.content);
                    
                    // Pr√©parer le contexte de conversation
                    const conversationContext = this.messageHistory.slice(-5).map(msg => ({
                        senderName: msg.senderName,
                        content: msg.content,
                        timestamp: msg.timestamp
                    }));
                    
                    const response = await ApiManager.generateResponseToUserMessage(
                        originalMessage.content, 
                        conversationContext
                    );
                    
                    const replyMessage = {
                        id: 'ai_resp_' + Date.now(),
                        senderId: response.playerId,
                        senderName: response.playerName,
                        senderAvatar: response.playerAvatar,
                        content: response.message,
                        type: originalMessage.type,
                        scene: originalMessage.scene,
                        timestamp: response.timestamp,
                        isOwn: false
                    };

                    this.messageHistory.push(replyMessage);
                    EventBus.emit('websocket-message-received', replyMessage);
                    
                    console.log('R√©ponse IA re√ßue:', replyMessage);
                    
                } catch (error) {
                    console.error('Erreur g√©n√©ration r√©ponse IA:', error);
                    // Fallback avec r√©ponse simple
                    this.simulateSimpleResponse(originalMessage);
                }
            }, delay);
        }
    }

    /**
     * Fallback : g√©n√®re un message simple sans IA
     */
    simulateSimpleMessage() {
        const simpleMessages = [
            "Quelqu'un a des conseils pour la perspective ?",
            "Cette exposition est vraiment inspirante !",
            "J'adore les techniques de cette √©poque",
            "Comment vous interpr√©tez cette ≈ìuvre ?",
            "Les couleurs de cette peinture sont fascinantes"
        ];

        const randomPlayer = this.virtualPlayers[Math.floor(Math.random() * this.virtualPlayers.length)];
        const randomMessage = simpleMessages[Math.floor(Math.random() * simpleMessages.length)];

        const message = {
            id: 'fallback_' + Date.now(),
            senderId: randomPlayer.id,
            senderName: randomPlayer.name,
            senderAvatar: randomPlayer.avatar,
            content: randomMessage,
            type: 'global',
            scene: this.getRandomScene(),
            timestamp: new Date().toISOString(),
            isOwn: false
        };

        this.messageHistory.push(message);
        EventBus.emit('websocket-message-received', message);
    }

    /**
     * Fallback : g√©n√®re une r√©ponse simple sans IA
     */
    simulateSimpleResponse(originalMessage) {
        const simpleResponses = [
            "Int√©ressant ! J'aimerais en savoir plus.",
            "Bonne remarque ! √áa me fait r√©fl√©chir.",
            "Je vois ce que tu veux dire.",
            "C'est une perspective int√©ressante !",
            "Merci pour le partage !",
            "Excellente question !",
            "√áa me rappelle quelque chose...",
            "Je suis d'accord avec toi."
        ];

        const randomPlayer = this.virtualPlayers[Math.floor(Math.random() * this.virtualPlayers.length)];
        const randomResponse = simpleResponses[Math.floor(Math.random() * simpleResponses.length)];

        const message = {
            id: 'fallback_resp_' + Date.now(),
            senderId: randomPlayer.id,
            senderName: randomPlayer.name,
            senderAvatar: randomPlayer.avatar,
            content: randomResponse,
            type: originalMessage.type,
            scene: originalMessage.scene,
            timestamp: new Date().toISOString(),
            isOwn: false
        };

        this.messageHistory.push(message);
        EventBus.emit('websocket-message-received', message);
    }

    /**
     * Retourne une sc√®ne al√©atoire
     */
    getRandomScene() {
        const scenes = ['Intro', 'Welcomeisle', 'Museumreception', 'Exhibitionroom', 'Sandbox'];
        return scenes[Math.floor(Math.random() * scenes.length)];
    }

    /**
     * Met √† jour la sc√®ne actuelle de l'utilisateur
     */
    updateUserScene(sceneKey) {
        if (this.currentUser) {
            this.currentUser.scene = sceneKey;
            
            // √âmettre la mise √† jour
            EventBus.emit('websocket-user-scene-changed', {
                userId: this.currentUser.id,
                scene: sceneKey
            });
        }
    }

    /**
     * R√©cup√®re la liste des joueurs connect√©s
     */
    getConnectedPlayers() {
        return this.connectedPlayers;
    }

    /**
     * R√©cup√®re l'historique des messages
     */
    getMessageHistory(limit = 50) {
        return this.messageHistory.slice(-limit);
    }

    /**
     * R√©cup√®re les joueurs dans la m√™me sc√®ne
     */
    getPlayersInScene(sceneKey) {
        return this.connectedPlayers.filter(player => player.scene === sceneKey);
    }

    /**
     * V√©rifie l'√©tat de la connexion
     */
    isWebSocketConnected() {
        return this.isConnected;
    }

    /**
     * Change le statut de l'utilisateur
     */
    updateUserStatus(status) {
        if (this.currentUser) {
            this.currentUser.status = status;
            
            EventBus.emit('websocket-user-status-changed', {
                userId: this.currentUser.id,
                status: status
            });
        }
    }

    /**
     * Nettoie le service
     */
    destroy() {
        this.stopAIMessageSimulation();
        this.messageHistory = [];
        this.connectedPlayers = [];
        this.currentUser = null;
        this.isConnected = false;
    }
}